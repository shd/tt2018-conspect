\section{Лекция 14}

\subsection{Индуктивные типы и равенства}

Возьмём исчисление конструкций. Эта теория весьма общая, и, чтобы сделать её более
пригодной для жизни, дополним её некоторыми базовыми конструкциями. Выделим две из них, которые будем рассматривать
--- \textbf{индуктивные типы} и \textbf{равенства}.

\medskip
\textbf{Индуктивный тип:} это обобщение конструкций, которые можно получить с помощью индукции,
пользуясь некоторым набором базовых утверждений и переходов. В качестве примера можно рассмотреть аксиоматику Пеано.
Здесь конструкторами (выражениями, конструирущими объекты надлежащего типа) будут $0$ и $n'$: если $n$ --- натуральное, то и $n'$ натуральное.

Рассмотрим реализацию натуральных чисел в языке Аренд.
\newpage
\begin{minted}{latex}
\data Nat
    | zero
    | suc Nat
\where {
    func \infixl 6 + (x y : Nat) : Nat \elim y
        | zero => x
        | suc y => suc (x + y)
}
\end{minted}

Здесь \texttt{zero} --- из ничего делает \texttt{Nat}, а \texttt{suc} из \texttt{Nat} делает \texttt{Nat}.
\texttt{where} говорит о связанных с \texttt{Nat} определениях, которые можно использовать, а \texttt{elim} представляет из себя сопоставление с образцом.

\medskip
\textbf{Равенство}. Традиционно рассматривается два типа равенств --- экстенсиональное и интенсиональное.
Интенсиональное основано на сравнении объектов по внутренней структуре, а экстенсиональное --- предполагает, что объекты неразличимы внешне.

Основными отличиями этих двух типов равенств являются разрешимость и сила. Интенсиональное --- разрешимо, но слабо, а экстенсиональное --- сильно, но неразрешимо.
Например, сравнение $0''$ и $0''$ интенсиональный подход успешно завершит, а при экстенсиональном подходе --- нам необходимо предоставить доказательство.

\subsection{Пути и равенство в Arend}
В основе подхода языка Arend лежит HoTT --- Homotopy Type Theory.
В нём произвольный тип $\alpha$ является некоторым пространством, а терм $A : \alpha$ --- точкой в нём.
Равенство же в топологии представляет из себя \textit{непрерывный} путь между двумя точками.

Введём интервальный тип \texttt{I}, представляющий из себя интервал $[l, r]$.
Определим тип \texttt{Path}.

\begin{minted}{latex}
\data Path (A : I -> \Type) (a : A left) (a' : A right)
    | path (\Pi (i : I) -> A i)
\end{minted} 

Разберём это определение. Здесь \texttt{A} --- это пространство, \texttt{a} и \texttt{a'} --- точки в нём.
Единственный конструктор является функцией, которая по левому концу пути вернёт конечную точку, а по правому концу --- начальную точку.

\newpage 

Теперь, с помощью путей, определим равенство.

\begin{minted}{latex}
\func \infix 1 = {A : \Type} (a a' : A) => Path (\lam _ => A) a a'
\end{minted}

Таким образом, равенство --- это функция, которая по типу и двум точкам возвращает
зависимый тип \texttt{Path}, соединяющий две точки.

\subsection{Основные функции}
\begin{itemize}
\item [\bf idp:] Вспомним определение равенства. Попробуем населить тип $0 = 0$. Это можно сделать так:

\begin{minted}{latex}
path (\lam _ => 0)
\end{minted}

\texttt{idp} является некоторым обобщением на произвольный неявный аргумент.

\begin{minted}{latex}
\cons idp {A : \Type} {a : A} => path (\lam _ => a)
\end{minted}

\item [\bf coe:] Функция \texttt{coe} позволяет <<разобрать>> равенство.

\begin{minted}{latex}
\func coe (A : I -> \Type) (a : A left) (i : I) : A i
\end{minted}

Первый аргумент показывает, на каких типах определено равенство. Второй --- начальное значение. Третий --- интервал.
Результатом будет применение \texttt{A} к \texttt{i}.

\item [\bf pmap:] Принимает функцию $f$ и тип равенства $A = B$. Возвращает тип $f(A) = f(B)$.
Пример: докажем, что если $a = b$, то $a+1 = b+1$.
\begin{minted}{latex}
\lemma example (a b : Nat) (p : a = b) 
    : (suc a = suc b) => pmap suc p
\end{minted}

\item [\bf absurd:] Позволяет получить любой тип из лжи (\texttt{Empty}).
\begin{minted}{latex}
    \func absurd {A : \Type} (x : Empty) : A
\end{minted}

\item [\bf rewrite:] Принимает тип равенства $A = B$, некоторое выражение $t$, и эта функция переписывает его, подставляя $B$ вместо $A$.
Пример:
\begin{minted}{latex}
\lemma example (x y : Nat) (f : Nat -> Nat)
: f (x + y) = f (y + x)
    => rewrite (NatSemiring.+-comm {x} {y}) idp
\end{minted}

\item [\bf transport:] Эта функция является основным механизмом для работы \texttt{rewrite}.
\begin{minted}{latex}
\func transport {A : \Type} (B : A -> \Type)
    {a a' : A} (p : a = a') (b : B a) : B a'
\end{minted}
\end{itemize}

\subsection{Сигма и пи-типы}
Иногда мы хотим оперировать с кортежами зависимых типов, например, если мы хотим,
чтобы одновременно удовлетворялись несколько условий. В языке Аренд сигма-тип --- это тип (зависимых) кортежей.

Покажем их использование на примере:
\begin{minted}{latex}
\data DivisibleBy5
    | mkDiv5 (n : Nat) (\Sigma (m : Nat) (m * 5 = n))

\func ten : DivisibleBy5 => mkDiv5 10 (2, idp)
\end{minted}

Здесь, чтобы доказать, что число 10 делится нацело на 5, мы предоставили кортеж из частного $m$ и доказательства, что $m \cdot 5 = 10$.

Также, с помощью сигма-типов удобно требовать выполнение нескольких условий одновременно.
\begin{minted}{latex}
\lemma example (a b k : Nat) (p : a + b < k)
    : (\Sigma (a < k) (b < k))
\end{minted}

Чтобы доказать эту лемму, потребуется предоставить доказательства \texttt{(a < k)} и \texttt{(b < k)}.
Получить произвольный элемент из сигма-типа можно с помощью паттерн-матчинга.

\medskip
Вспомним реализацию путей в языке Аренд. В ней использовался пи-тип~--- функция, возвращавшая начальную или конечную точку пути.
Итак, $\pi$-тип в Arend~--- это тип зависимых функций. Такая конструкция соответствует квантору всеобщности $\forall$, так как
тип \texttt{(\textbackslash Pi (x : A) -> B a)} населён, когда для любого элемента \texttt{a} из \texttt{A} существует элемент \texttt{B~a}. 

Например, представим, что мы определили понятие <<делится нацело>> и хотим определить понятие простого числа $n$.
Хочется проверить, что если число делит $n$ нацело, то оно либо $1$, либо $n$. Здесь можно применить пи-типы.
\begin{minted}{latex}
\Pi (d : Nat) (k : Divisible n d) -> ((d = 1) || (d = n))
\end{minted}

\newpage

\subsection{Prop, Universe}

Универсум --- это <<тип типов>>. В Arend присутствует следующая иерархия универсумов.

\begin{itemize}
    \item Все типы принадлежат универсуму 0. Например, \texttt{\textbackslash Type 0 => Int}
    \item Если есть функция, отображающая куда-нибудь тип, она принадлежит универсуму 1: \texttt{\textbackslash Type 1 => \textbackslash Type -> Int}
    \item Можно продолжать до произвольного универсума $n$.
\end{itemize}

Концепция похожа на сорта, но при этом она включает предыдущие в иерархии. Например, \texttt{\textbackslash Type 100 => Int}

\medskip
Заметим, что доказательств существования \texttt{Int} много --- например, $10$, $2$ или $9999$.
Давайте заведём некий набор типов, в которых всегда присутствует ровно один элемент если присутствует и назовём такой тип \textbf{собственными утверждениями}.
Чем такой тип интересен --- в нем есть утверждения, которые либо истинны, либо ложны.

Введём специальный универсум \texttt{Prop}. Этот универсум состоит только из тех значений, у которых единственный элемент.

\begin{minted}{latex}
\func isProp (A : \Type) => \Pi (a a' : A) -> a = a'
\end{minted}

Такой тип может быть либо пустым, либо одноэлементным (ложь/истина).

Теперь введём понятие множества (Set). Множеством будут называться все такие элементы, у которых единственное доказательство равенства.

\begin{minted}{latex}
\func isSet (A : \Type) => \Pi (a b : A) -> isProp (a = b)
\end{minted}

Наконец, научимся делать из любого типа \texttt{Prop}.

По типу \texttt{a} строим тип \texttt{||A||}
\begin{itemize}
    \item Если \texttt{(a : A)}, то \texttt{|a| : ||A||}
    \item Если \texttt{(x y : A)}, то \texttt{|x| = |y|}
\end{itemize}
Это называется \textbf{пропозициональным обрезанием}. В Аренде его можно сделать с помощью ключевого слова \texttt{\textbackslash truncated}.




